{"ast":null,"code":"import { Injectable, ɵɵdefineInjectable, EventEmitter, Component, NgZone, Input, Output, HostBinding, NgModule } from '@angular/core';\nimport { LinkedList, isBs3 } from 'ngx-bootstrap/utils';\nimport { CommonModule } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nfunction CarouselComponent_ol_1_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = ɵngcc0.ɵɵgetCurrentView();\n    ɵngcc0.ɵɵelementStart(0, \"li\", 7);\n    ɵngcc0.ɵɵlistener(\"click\", function CarouselComponent_ol_1_li_1_Template_li_click_0_listener() {\n      const restoredCtx = ɵngcc0.ɵɵrestoreView(_r7);\n      const i_r5 = restoredCtx.index;\n      const ctx_r6 = ɵngcc0.ɵɵnextContext(2);\n      return ɵngcc0.ɵɵresetView(ctx_r6.selectSlide(i_r5));\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const slide_r4 = ctx.$implicit;\n    ɵngcc0.ɵɵclassProp(\"active\", slide_r4.active === true);\n  }\n}\nfunction CarouselComponent_ol_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"ol\", 5);\n    ɵngcc0.ɵɵtemplate(1, CarouselComponent_ol_1_li_1_Template, 1, 2, \"li\", 6);\n    ɵngcc0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", ctx_r0.indicatorsSlides());\n  }\n}\nfunction CarouselComponent_a_4_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\", 11);\n    ɵngcc0.ɵɵtext(1, \"Previous\");\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\nfunction CarouselComponent_a_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r10 = ɵngcc0.ɵɵgetCurrentView();\n    ɵngcc0.ɵɵelementStart(0, \"a\", 8);\n    ɵngcc0.ɵɵlistener(\"click\", function CarouselComponent_a_4_Template_a_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r10);\n      const ctx_r9 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r9.previousSlide());\n    });\n    ɵngcc0.ɵɵelement(1, \"span\", 9);\n    ɵngcc0.ɵɵtemplate(2, CarouselComponent_a_4_span_2_Template, 2, 0, \"span\", 10);\n    ɵngcc0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵclassProp(\"disabled\", ctx_r1.activeSlide === 0 && ctx_r1.noWrap);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r1.isBs4);\n  }\n}\nfunction CarouselComponent_a_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = ɵngcc0.ɵɵgetCurrentView();\n    ɵngcc0.ɵɵelementStart(0, \"a\", 12);\n    ɵngcc0.ɵɵlistener(\"click\", function CarouselComponent_a_5_Template_a_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r12);\n      const ctx_r11 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r11.nextSlide());\n    });\n    ɵngcc0.ɵɵelement(1, \"span\", 13);\n    ɵngcc0.ɵɵelementStart(2, \"span\", 11);\n    ɵngcc0.ɵɵtext(3, \"Next\");\n    ɵngcc0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵclassProp(\"disabled\", ctx_r2.isLast(ctx_r2.activeSlide) && ctx_r2.noWrap);\n  }\n}\nconst _c0 = function (a0) {\n  return {\n    \"display\": a0\n  };\n};\nconst _c1 = [\"*\"];\nlet CarouselConfig = /*#__PURE__*/(() => {\n  class CarouselConfig {\n    constructor() {\n      /* Default interval of auto changing of slides */\n      this.interval = 5000;\n      /* Is loop of auto changing of slides can be paused */\n      this.noPause = false;\n      /* Is slides can wrap from the last to the first slide */\n      this.noWrap = false;\n      /* Show carousel-indicators */\n      this.showIndicators = true;\n      /* Slides can be paused on focus */\n      this.pauseOnFocus = false;\n      /* If `true` - carousel indicators indicate slides chunks works ONLY if singleSlideOffset = FALSE */\n      this.indicatorsByChunk = false;\n      /* If value more then 1 — carousel works in multilist mode */\n      this.itemsPerSlide = 1;\n      /* If `true` — carousel shifts by one element. By default carousel shifts by number\n          of visible elements (itemsPerSlide field) */\n      this.singleSlideOffset = false;\n    }\n  }\n  CarouselConfig.ɵfac = function CarouselConfig_Factory(t) {\n    return new (t || CarouselConfig)();\n  };\n  /** @nocollapse */\n  CarouselConfig.ɵprov = ɵɵdefineInjectable({\n    factory: function CarouselConfig_Factory() {\n      return new CarouselConfig();\n    },\n    token: CarouselConfig,\n    providedIn: \"root\"\n  });\n  return CarouselConfig;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nif (false) {\n  /** @type {?} */\n  CarouselConfig.prototype.interval;\n  /** @type {?} */\n  CarouselConfig.prototype.noPause;\n  /** @type {?} */\n  CarouselConfig.prototype.noWrap;\n  /** @type {?} */\n  CarouselConfig.prototype.showIndicators;\n  /** @type {?} */\n  CarouselConfig.prototype.pauseOnFocus;\n  /** @type {?} */\n  CarouselConfig.prototype.indicatorsByChunk;\n  /** @type {?} */\n  CarouselConfig.prototype.itemsPerSlide;\n  /** @type {?} */\n  CarouselConfig.prototype.singleSlideOffset;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Returns the index of the last element in the array where predicate is true, and -1\n * otherwise.\n * @template T\n * @param {?} array The source array to search in\n * @param {?} predicate find calls predicate once for each element of the array, in descending\n * order, until it finds one where predicate returns true. If such an element is found,\n * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n * @return {?}\n */\nfunction findLastIndex(array, predicate) {\n  /** @type {?} */\n  let l = array.length;\n  while (l--) {\n    if (predicate(array[l], l, array)) {\n      return l;\n    }\n  }\n  return -1;\n}\n/**\n * @template T\n * @param {?} array\n * @param {?} size\n * @return {?}\n */\nfunction chunkByNumber(array, size) {\n  /** @type {?} */\n  const out = [];\n  /** @type {?} */\n  const n = Math.ceil(array.length / size);\n  /** @type {?} */\n  let i = 0;\n  while (i < n) {\n    /** @type {?} */\n    const chunk = array.splice(0, i === n - 1 && size < array.length ? array.length : size);\n    out.push(chunk);\n    i++;\n  }\n  return out;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @enum {number} */\nconst Direction = {\n  UNKNOWN: 0,\n  NEXT: 1,\n  PREV: 2\n};\nDirection[Direction.UNKNOWN] = 'UNKNOWN';\nDirection[Direction.NEXT] = 'NEXT';\nDirection[Direction.PREV] = 'PREV';\n/**\n * Base element to create carousel\n */\nlet CarouselComponent = /*#__PURE__*/(() => {\n  class CarouselComponent {\n    /**\n     * @param {?} config\n     * @param {?} ngZone\n     */\n    constructor(config, ngZone) {\n      this.ngZone = ngZone;\n      /* If `true` - carousel indicators indicate slides chunks\n           works ONLY if singleSlideOffset = FALSE */\n      this.indicatorsByChunk = false;\n      /* If value more then 1 — carousel works in multilist mode */\n      this.itemsPerSlide = 1;\n      /* If `true` — carousel shifts by one element. By default carousel shifts by number\n           of visible elements (itemsPerSlide field) */\n      this.singleSlideOffset = false;\n      /**\n       * Turn on/off animation. Animation doesn't work for multilist carousel\n       */\n      this.isAnimated = false;\n      /**\n       * Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property\n       */\n      this.activeSlideChange = new EventEmitter(false);\n      /**\n       * Will be emitted when active slides has been changed in multilist mode\n       */\n      this.slideRangeChange = new EventEmitter();\n      /* Index to start display slides from it */\n      this.startFromIndex = 0;\n      this._slides = new LinkedList();\n      this._currentVisibleSlidesIndex = 0;\n      this.destroyed = false;\n      this.getActive =\n      /**\n      * @param {?} slide\n      * @return {?}\n      */\n      slide => slide.active;\n      this.makeSlidesConsistent =\n      /**\n      * @param {?} slides\n      * @return {?}\n      */\n      slides => {\n        slides.forEach(\n        /**\n        * @param {?} slide\n        * @param {?} index\n        * @return {?}\n        */\n        (slide, index) => slide.item.order = index);\n      };\n      Object.assign(this, config);\n    }\n    /**\n     * Index of currently displayed slide(started for 0)\n     * @param {?} index\n     * @return {?}\n     */\n    set activeSlide(index) {\n      if (this.multilist) {\n        return;\n      }\n      if (this._slides.length && index !== this._currentActiveSlide) {\n        this._select(index);\n      }\n    }\n    /**\n     * @return {?}\n     */\n    get activeSlide() {\n      return this._currentActiveSlide;\n    }\n    /**\n     * Delay of item cycling in milliseconds. If false, carousel won't cycle\n     * automatically.\n     * @return {?}\n     */\n    get interval() {\n      return this._interval;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set interval(value) {\n      this._interval = value;\n      this.restartTimer();\n    }\n    /**\n     * @return {?}\n     */\n    get slides() {\n      return this._slides.toArray();\n    }\n    /**\n     * @return {?}\n     */\n    get isBs4() {\n      return !isBs3();\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewInit() {\n      setTimeout(\n      /**\n      * @return {?}\n      */\n      () => {\n        if (this.singleSlideOffset) {\n          this.indicatorsByChunk = false;\n        }\n        if (this.multilist) {\n          this._chunkedSlides = chunkByNumber(this.mapSlidesAndIndexes(), this.itemsPerSlide);\n          this.selectInitialSlides();\n        }\n      }, 0);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n      this.destroyed = true;\n    }\n    /**\n     * Adds new slide. If this slide is first in collection - set it as active\n     * and starts auto changing\n     * @param {?} slide\n     * @return {?}\n     */\n    addSlide(slide) {\n      this._slides.add(slide);\n      if (this.multilist && this._slides.length <= this.itemsPerSlide) {\n        slide.active = true;\n      }\n      if (!this.multilist && this.isAnimated) {\n        slide.isAnimated = true;\n      }\n      if (!this.multilist && this._slides.length === 1) {\n        this._currentActiveSlide = undefined;\n        this.activeSlide = 0;\n        this.play();\n      }\n      if (this.multilist && this._slides.length > this.itemsPerSlide) {\n        this.play();\n      }\n    }\n    /**\n     * Removes specified slide. If this slide is active - will roll to another\n     * slide\n     * @param {?} slide\n     * @return {?}\n     */\n    removeSlide(slide) {\n      /** @type {?} */\n      const remIndex = this._slides.indexOf(slide);\n      if (this._currentActiveSlide === remIndex) {\n        // removing of active slide\n        /** @type {?} */\n        let nextSlideIndex = void 0;\n        if (this._slides.length > 1) {\n          // if this slide last - will roll to first slide, if noWrap flag is\n          // FALSE or to previous, if noWrap is TRUE in case, if this slide in\n          // middle of collection, index of next slide is same to removed\n          nextSlideIndex = !this.isLast(remIndex) ? remIndex : this.noWrap ? remIndex - 1 : 0;\n        }\n        this._slides.remove(remIndex);\n        // prevents exception with changing some value after checking\n        setTimeout(\n        /**\n        * @return {?}\n        */\n        () => {\n          this._select(nextSlideIndex);\n        }, 0);\n      } else {\n        this._slides.remove(remIndex);\n        /** @type {?} */\n        const currentSlideIndex = this.getCurrentSlideIndex();\n        setTimeout(\n        /**\n        * @return {?}\n        */\n        () => {\n          // after removing, need to actualize index of current active slide\n          this._currentActiveSlide = currentSlideIndex;\n          this.activeSlideChange.emit(this._currentActiveSlide);\n        }, 0);\n      }\n    }\n    /**\n     * @param {?=} force\n     * @return {?}\n     */\n    nextSlideFromInterval(force = false) {\n      this.move(Direction.NEXT, force);\n    }\n    /**\n     * Rolling to next slide\n     * @param {?=} force\n     * @return {?}\n     */\n    nextSlide(force = false) {\n      if (this.isPlaying) {\n        this.restartTimer();\n      }\n      this.move(Direction.NEXT, force);\n    }\n    /**\n     * Rolling to previous slide\n     * @param {?=} force\n     * @return {?}\n     */\n    previousSlide(force = false) {\n      if (this.isPlaying) {\n        this.restartTimer();\n      }\n      this.move(Direction.PREV, force);\n    }\n    /**\n     * @return {?}\n     */\n    getFirstVisibleIndex() {\n      return this.slides.findIndex(this.getActive);\n    }\n    /**\n     * @return {?}\n     */\n    getLastVisibleIndex() {\n      return findLastIndex(this.slides, this.getActive);\n    }\n    /**\n     * @param {?} direction\n     * @param {?=} force\n     * @return {?}\n     */\n    move(direction, force = false) {\n      /** @type {?} */\n      const firstVisibleIndex = this.getFirstVisibleIndex();\n      /** @type {?} */\n      const lastVisibleIndex = this.getLastVisibleIndex();\n      if (this.noWrap) {\n        if (direction === Direction.NEXT && this.isLast(lastVisibleIndex) || direction === Direction.PREV && firstVisibleIndex === 0) {\n          return;\n        }\n      }\n      if (!this.multilist) {\n        this.activeSlide = this.findNextSlideIndex(direction, force);\n      } else {\n        this.moveMultilist(direction);\n      }\n    }\n    /**\n     * Swith slides by enter, space and arrows keys\n     * \\@internal\n     * @param {?} event\n     * @return {?}\n     */\n    keydownPress(event) {\n      // tslint:disable-next-line:deprecation\n      if (event.keyCode === 13 || event.key === 'Enter' || event.keyCode === 32 || event.key === 'Space') {\n        this.nextSlide();\n        event.preventDefault();\n        return;\n      }\n      // tslint:disable-next-line:deprecation\n      if (event.keyCode === 37 || event.key === 'LeftArrow') {\n        this.previousSlide();\n        return;\n      }\n      // tslint:disable-next-line:deprecation\n      if (event.keyCode === 39 || event.key === 'RightArrow') {\n        this.nextSlide();\n        return;\n      }\n    }\n    /**\n     * Play on mouse leave\n     * \\@internal\n     * @return {?}\n     */\n    onMouseLeave() {\n      if (!this.pauseOnFocus) {\n        this.play();\n      }\n    }\n    /**\n     * Play on mouse up\n     * \\@internal\n     * @return {?}\n     */\n    onMouseUp() {\n      if (!this.pauseOnFocus) {\n        this.play();\n      }\n    }\n    /**\n     * When slides on focus autoplay is stopped(optional)\n     * \\@internal\n     * @return {?}\n     */\n    pauseFocusIn() {\n      if (this.pauseOnFocus) {\n        this.isPlaying = false;\n        this.resetTimer();\n      }\n    }\n    /**\n     * When slides out of focus autoplay is started\n     * \\@internal\n     * @return {?}\n     */\n    pauseFocusOut() {\n      this.play();\n    }\n    /**\n     * Rolling to specified slide\n     * @param {?} index\n     * @return {?}\n     */\n    selectSlide(index) {\n      if (this.isPlaying) {\n        this.restartTimer();\n      }\n      if (!this.multilist) {\n        this.activeSlide = this.indicatorsByChunk ? index * this.itemsPerSlide : index;\n      } else {\n        this.selectSlideRange(this.indicatorsByChunk ? index * this.itemsPerSlide : index);\n      }\n    }\n    /**\n     * Starts a auto changing of slides\n     * @return {?}\n     */\n    play() {\n      if (!this.isPlaying) {\n        this.isPlaying = true;\n        this.restartTimer();\n      }\n    }\n    /**\n     * Stops a auto changing of slides\n     * @return {?}\n     */\n    pause() {\n      if (!this.noPause) {\n        this.isPlaying = false;\n        this.resetTimer();\n      }\n    }\n    /**\n     * Finds and returns index of currently displayed slide\n     * @return {?}\n     */\n    getCurrentSlideIndex() {\n      return this._slides.findIndex(this.getActive);\n    }\n    /**\n     * Defines, whether the specified index is last in collection\n     * @param {?} index\n     * @return {?}\n     */\n    isLast(index) {\n      return index + 1 >= this._slides.length;\n    }\n    /**\n     * Defines, whether the specified index is first in collection\n     * @param {?} index\n     * @return {?}\n     */\n    isFirst(index) {\n      return index === 0;\n    }\n    /**\n     * @return {?}\n     */\n    indicatorsSlides() {\n      return this.slides.filter(\n      /**\n      * @param {?} slide\n      * @param {?} index\n      * @return {?}\n      */\n      (slide, index) => !this.indicatorsByChunk || index % this.itemsPerSlide === 0);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    selectInitialSlides() {\n      /** @type {?} */\n      const startIndex = this.startFromIndex <= this._slides.length ? this.startFromIndex : 0;\n      this.hideSlides();\n      if (this.singleSlideOffset) {\n        this._slidesWithIndexes = this.mapSlidesAndIndexes();\n        if (this._slides.length - startIndex < this.itemsPerSlide) {\n          /** @type {?} */\n          const slidesToAppend = this._slidesWithIndexes.slice(0, startIndex);\n          this._slidesWithIndexes = [...this._slidesWithIndexes, ...slidesToAppend].slice(slidesToAppend.length).slice(0, this.itemsPerSlide);\n        } else {\n          this._slidesWithIndexes = this._slidesWithIndexes.slice(startIndex, startIndex + this.itemsPerSlide);\n        }\n        this._slidesWithIndexes.forEach(\n        /**\n        * @param {?} slide\n        * @return {?}\n        */\n        slide => slide.item.active = true);\n        this.makeSlidesConsistent(this._slidesWithIndexes);\n      } else {\n        this.selectRangeByNestedIndex(startIndex);\n      }\n      this.slideRangeChange.emit(this.getVisibleIndexes());\n    }\n    /**\n     * Defines next slide index, depending of direction\n     * @private\n     * @param {?} direction\n     * @param {?} force\n     * @return {?}\n     */\n    findNextSlideIndex(direction, force) {\n      /** @type {?} */\n      let nextSlideIndex = 0;\n      if (!force && this.isLast(this.activeSlide) && direction !== Direction.PREV && this.noWrap) {\n        return undefined;\n      }\n      switch (direction) {\n        case Direction.NEXT:\n          // if this is last slide, not force, looping is disabled\n          // and need to going forward - select current slide, as a next\n          nextSlideIndex = !this.isLast(this._currentActiveSlide) ? this._currentActiveSlide + 1 : !force && this.noWrap ? this._currentActiveSlide : 0;\n          break;\n        case Direction.PREV:\n          // if this is first slide, not force, looping is disabled\n          // and need to going backward - select current slide, as a next\n          nextSlideIndex = this._currentActiveSlide > 0 ? this._currentActiveSlide - 1 : !force && this.noWrap ? this._currentActiveSlide : this._slides.length - 1;\n          break;\n        default:\n          throw new Error('Unknown direction');\n      }\n      return nextSlideIndex;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    mapSlidesAndIndexes() {\n      return this.slides.slice().map(\n      /**\n      * @param {?} slide\n      * @param {?} index\n      * @return {?}\n      */\n      (slide, index) => {\n        return {\n          index,\n          item: slide\n        };\n      });\n    }\n    /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    selectSlideRange(index) {\n      if (this.isIndexInRange(index)) {\n        return;\n      }\n      this.hideSlides();\n      if (!this.singleSlideOffset) {\n        this.selectRangeByNestedIndex(index);\n      } else {\n        /** @type {?} */\n        const startIndex = this.isIndexOnTheEdges(index) ? index : index - this.itemsPerSlide + 1;\n        /** @type {?} */\n        const endIndex = this.isIndexOnTheEdges(index) ? index + this.itemsPerSlide : index + 1;\n        this._slidesWithIndexes = this.mapSlidesAndIndexes().slice(startIndex, endIndex);\n        this.makeSlidesConsistent(this._slidesWithIndexes);\n        this._slidesWithIndexes.forEach(\n        /**\n        * @param {?} slide\n        * @return {?}\n        */\n        slide => slide.item.active = true);\n      }\n      this.slideRangeChange.emit(this.getVisibleIndexes());\n    }\n    /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    selectRangeByNestedIndex(index) {\n      /** @type {?} */\n      const selectedRange = this._chunkedSlides.map(\n      /**\n      * @param {?} slidesList\n      * @param {?} i\n      * @return {?}\n      */\n      (slidesList, i) => {\n        return {\n          index: i,\n          list: slidesList\n        };\n      }).find(\n      /**\n      * @param {?} slidesList\n      * @return {?}\n      */\n      slidesList => {\n        return slidesList.list.find(\n        /**\n        * @param {?} slide\n        * @return {?}\n        */\n        slide => slide.index === index) !== undefined;\n      });\n      this._currentVisibleSlidesIndex = selectedRange.index;\n      this._chunkedSlides[selectedRange.index].forEach(\n      /**\n      * @param {?} slide\n      * @return {?}\n      */\n      slide => {\n        slide.item.active = true;\n      });\n    }\n    /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    isIndexOnTheEdges(index) {\n      return index + 1 - this.itemsPerSlide <= 0 || index + this.itemsPerSlide <= this._slides.length;\n    }\n    /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    isIndexInRange(index) {\n      if (this.singleSlideOffset) {\n        /** @type {?} */\n        const visibleIndexes = this._slidesWithIndexes.map(\n        /**\n        * @param {?} slide\n        * @return {?}\n        */\n        slide => slide.index);\n        return visibleIndexes.indexOf(index) >= 0;\n      }\n      return index <= this.getLastVisibleIndex() && index >= this.getFirstVisibleIndex();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    hideSlides() {\n      this.slides.forEach(\n      /**\n      * @param {?} slide\n      * @return {?}\n      */\n      slide => slide.active = false);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    isVisibleSlideListLast() {\n      return this._currentVisibleSlidesIndex === this._chunkedSlides.length - 1;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    isVisibleSlideListFirst() {\n      return this._currentVisibleSlidesIndex === 0;\n    }\n    /**\n     * @private\n     * @param {?} direction\n     * @return {?}\n     */\n    moveSliderByOneItem(direction) {\n      /** @type {?} */\n      let firstVisibleIndex;\n      /** @type {?} */\n      let lastVisibleIndex;\n      /** @type {?} */\n      let indexToHide;\n      /** @type {?} */\n      let indexToShow;\n      if (this.noWrap) {\n        firstVisibleIndex = this.getFirstVisibleIndex();\n        lastVisibleIndex = this.getLastVisibleIndex();\n        indexToHide = direction === Direction.NEXT ? firstVisibleIndex : lastVisibleIndex;\n        indexToShow = direction !== Direction.NEXT ? firstVisibleIndex - 1 : !this.isLast(lastVisibleIndex) ? lastVisibleIndex + 1 : 0;\n        this._slides.get(indexToHide).active = false;\n        this._slides.get(indexToShow).active = true;\n        /** @type {?} */\n        const slidesToReorder = this.mapSlidesAndIndexes().filter(\n        /**\n        * @param {?} slide\n        * @return {?}\n        */\n        slide => slide.item.active);\n        this.makeSlidesConsistent(slidesToReorder);\n        this.slideRangeChange.emit(this.getVisibleIndexes());\n      } else {\n        /** @type {?} */\n        let displayedIndex;\n        firstVisibleIndex = this._slidesWithIndexes[0].index;\n        lastVisibleIndex = this._slidesWithIndexes[this._slidesWithIndexes.length - 1].index;\n        if (direction === Direction.NEXT) {\n          this._slidesWithIndexes.shift();\n          displayedIndex = this.isLast(lastVisibleIndex) ? 0 : lastVisibleIndex + 1;\n          this._slidesWithIndexes.push({\n            index: displayedIndex,\n            item: this._slides.get(displayedIndex)\n          });\n        } else {\n          this._slidesWithIndexes.pop();\n          displayedIndex = this.isFirst(firstVisibleIndex) ? this._slides.length - 1 : firstVisibleIndex - 1;\n          this._slidesWithIndexes = [{\n            index: displayedIndex,\n            item: this._slides.get(displayedIndex)\n          }, ...this._slidesWithIndexes];\n        }\n        this.hideSlides();\n        this._slidesWithIndexes.forEach(\n        /**\n        * @param {?} slide\n        * @return {?}\n        */\n        slide => slide.item.active = true);\n        this.makeSlidesConsistent(this._slidesWithIndexes);\n        this.slideRangeChange.emit(this._slidesWithIndexes.map(\n        /**\n        * @param {?} slide\n        * @return {?}\n        */\n        slide => slide.index));\n      }\n    }\n    /**\n     * @private\n     * @param {?} direction\n     * @return {?}\n     */\n    moveMultilist(direction) {\n      if (this.singleSlideOffset) {\n        this.moveSliderByOneItem(direction);\n      } else {\n        this.hideSlides();\n        if (this.noWrap) {\n          this._currentVisibleSlidesIndex = direction === Direction.NEXT ? this._currentVisibleSlidesIndex + 1 : this._currentVisibleSlidesIndex - 1;\n        } else {\n          if (direction === Direction.NEXT) {\n            this._currentVisibleSlidesIndex = this.isVisibleSlideListLast() ? 0 : this._currentVisibleSlidesIndex + 1;\n          } else {\n            this._currentVisibleSlidesIndex = this.isVisibleSlideListFirst() ? this._chunkedSlides.length - 1 : this._currentVisibleSlidesIndex - 1;\n          }\n        }\n        this._chunkedSlides[this._currentVisibleSlidesIndex].forEach(\n        /**\n        * @param {?} slide\n        * @return {?}\n        */\n        slide => slide.item.active = true);\n        this.slideRangeChange.emit(this.getVisibleIndexes());\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    getVisibleIndexes() {\n      if (!this.singleSlideOffset) {\n        return this._chunkedSlides[this._currentVisibleSlidesIndex].map(\n        /**\n        * @param {?} slide\n        * @return {?}\n        */\n        slide => slide.index);\n      } else {\n        return this._slidesWithIndexes.map(\n        /**\n        * @param {?} slide\n        * @return {?}\n        */\n        slide => slide.index);\n      }\n    }\n    /**\n     * Sets a slide, which specified through index, as active\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    _select(index) {\n      if (isNaN(index)) {\n        this.pause();\n        return;\n      }\n      if (!this.multilist) {\n        /** @type {?} */\n        const currentSlide = this._slides.get(this._currentActiveSlide);\n        if (currentSlide) {\n          currentSlide.active = false;\n        }\n      }\n      /** @type {?} */\n      const nextSlide = this._slides.get(index);\n      if (nextSlide) {\n        this._currentActiveSlide = index;\n        nextSlide.active = true;\n        this.activeSlide = index;\n        this.activeSlideChange.emit(index);\n      }\n    }\n    /**\n     * Starts loop of auto changing of slides\n     * @private\n     * @return {?}\n     */\n    restartTimer() {\n      this.resetTimer();\n      /** @type {?} */\n      const interval = +this.interval;\n      if (!isNaN(interval) && interval > 0) {\n        this.currentInterval = this.ngZone.runOutsideAngular(\n        /**\n        * @return {?}\n        */\n        () => {\n          return setInterval(\n          /**\n          * @return {?}\n          */\n          () => {\n            /** @type {?} */\n            const nInterval = +this.interval;\n            this.ngZone.run(\n            /**\n            * @return {?}\n            */\n            () => {\n              if (this.isPlaying && !isNaN(this.interval) && nInterval > 0 && this.slides.length) {\n                this.nextSlideFromInterval();\n              } else {\n                this.pause();\n              }\n            });\n          }, interval);\n        });\n      }\n    }\n    /**\n     * @return {?}\n     */\n    get multilist() {\n      return this.itemsPerSlide > 1;\n    }\n    /**\n     * Stops loop of auto changing of slides\n     * @private\n     * @return {?}\n     */\n    resetTimer() {\n      if (this.currentInterval) {\n        clearInterval(this.currentInterval);\n        this.currentInterval = void 0;\n      }\n    }\n  }\n  CarouselComponent.ɵfac = function CarouselComponent_Factory(t) {\n    return new (t || CarouselComponent)(ɵngcc0.ɵɵdirectiveInject(CarouselConfig), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n  CarouselComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: CarouselComponent,\n    selectors: [[\"carousel\"]],\n    inputs: {\n      indicatorsByChunk: \"indicatorsByChunk\",\n      itemsPerSlide: \"itemsPerSlide\",\n      singleSlideOffset: \"singleSlideOffset\",\n      isAnimated: \"isAnimated\",\n      startFromIndex: \"startFromIndex\",\n      activeSlide: \"activeSlide\",\n      interval: \"interval\",\n      noWrap: \"noWrap\",\n      noPause: \"noPause\",\n      showIndicators: \"showIndicators\",\n      pauseOnFocus: \"pauseOnFocus\"\n    },\n    outputs: {\n      activeSlideChange: \"activeSlideChange\",\n      slideRangeChange: \"slideRangeChange\"\n    },\n    ngContentSelectors: _c1,\n    decls: 6,\n    vars: 6,\n    consts: [[\"tabindex\", \"0\", 1, \"carousel\", \"slide\", 3, \"mouseenter\", \"mouseleave\", \"mouseup\", \"keydown\", \"focusin\", \"focusout\"], [\"class\", \"carousel-indicators\", 4, \"ngIf\"], [1, \"carousel-inner\", 3, \"ngStyle\"], [\"class\", \"left carousel-control carousel-control-prev\", \"tabindex\", \"0\", \"role\", \"button\", 3, \"disabled\", \"click\", 4, \"ngIf\"], [\"class\", \"right carousel-control carousel-control-next\", \"tabindex\", \"0\", \"role\", \"button\", 3, \"disabled\", \"click\", 4, \"ngIf\"], [1, \"carousel-indicators\"], [3, \"active\", \"click\", 4, \"ngFor\", \"ngForOf\"], [3, \"click\"], [\"tabindex\", \"0\", \"role\", \"button\", 1, \"left\", \"carousel-control\", \"carousel-control-prev\", 3, \"click\"], [\"aria-hidden\", \"true\", 1, \"icon-prev\", \"carousel-control-prev-icon\"], [\"class\", \"sr-only\", 4, \"ngIf\"], [1, \"sr-only\"], [\"tabindex\", \"0\", \"role\", \"button\", 1, \"right\", \"carousel-control\", \"carousel-control-next\", 3, \"click\"], [\"aria-hidden\", \"true\", 1, \"icon-next\", \"carousel-control-next-icon\"]],\n    template: function CarouselComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵlistener(\"mouseenter\", function CarouselComponent_Template_div_mouseenter_0_listener() {\n          return ctx.pause();\n        })(\"mouseleave\", function CarouselComponent_Template_div_mouseleave_0_listener() {\n          return ctx.onMouseLeave();\n        })(\"mouseup\", function CarouselComponent_Template_div_mouseup_0_listener() {\n          return ctx.onMouseUp();\n        })(\"keydown\", function CarouselComponent_Template_div_keydown_0_listener($event) {\n          return ctx.keydownPress($event);\n        })(\"focusin\", function CarouselComponent_Template_div_focusin_0_listener() {\n          return ctx.pauseFocusIn();\n        })(\"focusout\", function CarouselComponent_Template_div_focusout_0_listener() {\n          return ctx.pauseFocusOut();\n        });\n        ɵngcc0.ɵɵtemplate(1, CarouselComponent_ol_1_Template, 2, 1, \"ol\", 1);\n        ɵngcc0.ɵɵelementStart(2, \"div\", 2);\n        ɵngcc0.ɵɵprojection(3);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtemplate(4, CarouselComponent_a_4_Template, 3, 3, \"a\", 3);\n        ɵngcc0.ɵɵtemplate(5, CarouselComponent_a_5_Template, 4, 2, \"a\", 4);\n        ɵngcc0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.showIndicators && ctx.slides.length > 1);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngStyle\", ɵngcc0.ɵɵpureFunction1(4, _c0, ctx.multilist ? \"flex\" : \"block\"));\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.slides.length > 1);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.slides.length > 1);\n      }\n    },\n    dependencies: [ɵngcc1.NgForOf, ɵngcc1.NgIf, ɵngcc1.NgStyle],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n  return CarouselComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nif (false) {\n  /** @type {?} */\n  CarouselComponent.prototype.noWrap;\n  /** @type {?} */\n  CarouselComponent.prototype.noPause;\n  /** @type {?} */\n  CarouselComponent.prototype.showIndicators;\n  /** @type {?} */\n  CarouselComponent.prototype.pauseOnFocus;\n  /** @type {?} */\n  CarouselComponent.prototype.indicatorsByChunk;\n  /** @type {?} */\n  CarouselComponent.prototype.itemsPerSlide;\n  /** @type {?} */\n  CarouselComponent.prototype.singleSlideOffset;\n  /**\n   * Turn on/off animation. Animation doesn't work for multilist carousel\n   * @type {?}\n   */\n  CarouselComponent.prototype.isAnimated;\n  /**\n   * Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property\n   * @type {?}\n   */\n  CarouselComponent.prototype.activeSlideChange;\n  /**\n   * Will be emitted when active slides has been changed in multilist mode\n   * @type {?}\n   */\n  CarouselComponent.prototype.slideRangeChange;\n  /** @type {?} */\n  CarouselComponent.prototype.startFromIndex;\n  /**\n   * @type {?}\n   * @protected\n   */\n  CarouselComponent.prototype.currentInterval;\n  /**\n   * @type {?}\n   * @protected\n   */\n  CarouselComponent.prototype._currentActiveSlide;\n  /**\n   * @type {?}\n   * @protected\n   */\n  CarouselComponent.prototype._interval;\n  /**\n   * @type {?}\n   * @protected\n   */\n  CarouselComponent.prototype._slides;\n  /**\n   * @type {?}\n   * @protected\n   */\n  CarouselComponent.prototype._chunkedSlides;\n  /**\n   * @type {?}\n   * @protected\n   */\n  CarouselComponent.prototype._slidesWithIndexes;\n  /**\n   * @type {?}\n   * @protected\n   */\n  CarouselComponent.prototype._currentVisibleSlidesIndex;\n  /**\n   * @type {?}\n   * @protected\n   */\n  CarouselComponent.prototype.isPlaying;\n  /**\n   * @type {?}\n   * @protected\n   */\n  CarouselComponent.prototype.destroyed;\n  /** @type {?} */\n  CarouselComponent.prototype.getActive;\n  /**\n   * @type {?}\n   * @private\n   */\n  CarouselComponent.prototype.makeSlidesConsistent;\n  /**\n   * @type {?}\n   * @private\n   */\n  CarouselComponent.prototype.ngZone;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nlet SlideComponent = /*#__PURE__*/(() => {\n  class SlideComponent {\n    /**\n     * @param {?} carousel\n     */\n    constructor(carousel) {\n      this.itemWidth = '100%';\n      this.order = 0;\n      /**\n       * Wraps element by appropriate CSS classes\n       */\n      this.addClass = true;\n      this.carousel = carousel;\n    }\n    /**\n     * Fires changes in container collection after adding a new slide instance\n     * @return {?}\n     */\n    ngOnInit() {\n      this.carousel.addSlide(this);\n      this.itemWidth = `${100 / this.carousel.itemsPerSlide}%`;\n    }\n    /**\n     * Fires changes in container collection after removing of this slide instance\n     * @return {?}\n     */\n    ngOnDestroy() {\n      this.carousel.removeSlide(this);\n    }\n  }\n  SlideComponent.ɵfac = function SlideComponent_Factory(t) {\n    return new (t || SlideComponent)(ɵngcc0.ɵɵdirectiveInject(CarouselComponent));\n  };\n  SlideComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: SlideComponent,\n    selectors: [[\"slide\"]],\n    hostVars: 13,\n    hostBindings: function SlideComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"aria-hidden\", !ctx.active);\n        ɵngcc0.ɵɵstyleProp(\"width\", ctx.itemWidth)(\"order\", ctx.order);\n        ɵngcc0.ɵɵclassProp(\"item\", ctx.addClass)(\"carousel-item\", ctx.addClass)(\"active\", ctx.active)(\"carousel-animation\", ctx.isAnimated);\n      }\n    },\n    inputs: {\n      active: \"active\"\n    },\n    ngContentSelectors: _c1,\n    decls: 2,\n    vars: 2,\n    consts: [[1, \"item\"]],\n    template: function SlideComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵprojection(1);\n        ɵngcc0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"active\", ctx.active);\n      }\n    },\n    styles: [\".carousel-animation[_nghost-%COMP%] {\\n       transition: opacity 0.6s ease, visibility 0.6s ease;\\n       float: left;\\n    }\\n    .carousel-animation.active[_nghost-%COMP%] {\\n      opacity: 1;\\n      visibility: visible;\\n    }\\n    .carousel-animation[_nghost-%COMP%]:not(.active) {\\n      display: block;\\n      position: absolute;\\n      opacity: 0;\\n      visibility: hidden;\\n    }\"]\n  });\n  /** @nocollapse */\n  return SlideComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nif (false) {\n  /**\n   * Is current slide active\n   * @type {?}\n   */\n  SlideComponent.prototype.active;\n  /** @type {?} */\n  SlideComponent.prototype.itemWidth;\n  /** @type {?} */\n  SlideComponent.prototype.order;\n  /** @type {?} */\n  SlideComponent.prototype.isAnimated;\n  /**\n   * Wraps element by appropriate CSS classes\n   * @type {?}\n   */\n  SlideComponent.prototype.addClass;\n  /**\n   * Link to Parent(container-collection) component\n   * @type {?}\n   * @protected\n   */\n  SlideComponent.prototype.carousel;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nlet CarouselModule = /*#__PURE__*/(() => {\n  class CarouselModule {\n    /**\n     * @return {?}\n     */\n    static forRoot() {\n      return {\n        ngModule: CarouselModule,\n        providers: []\n      };\n    }\n  }\n  CarouselModule.ɵfac = function CarouselModule_Factory(t) {\n    return new (t || CarouselModule)();\n  };\n  CarouselModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: CarouselModule\n  });\n  CarouselModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return CarouselModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CarouselModule, {\n    declarations: function () {\n      return [SlideComponent, CarouselComponent];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [SlideComponent, CarouselComponent];\n    }\n  });\n})();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { CarouselComponent, CarouselConfig, CarouselModule, SlideComponent };\n\n//# sourceMappingURL=ngx-bootstrap-carousel.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}